
//@TODO move the following code into a separate file so that MyData is imported
// external.rs will be generated by OV-cli based on parameters that are passed to it.
// it describes the data model that the function contained in a Rule is run on
// use mock external.rs so that we can build

// deny unsafe code
#![deny(unsafe_code)]
#![warn(
    ellipsis_inclusive_range_patterns,
    trivial_casts,
    trivial_numeric_casts,
    unreachable_pub,
    unused,
    unused_results,
    rust_2018_idioms
)]
#![warn(
    clippy::all,
    clippy::correctness,
    clippy::perf,
    clippy::complexity,
    clippy::style,
    clippy::pedantic,
    clippy::shadow_reuse,
    clippy::shadow_same,
    clippy::shadow_unrelated,
    clippy::pub_enum_variant_names,
    clippy::string_add,
    clippy::string_add_assign,
    clippy::redundant_clone,
    clippy::empty_enum,
    clippy::explicit_iter_loop,
    clippy::match_same_arms,
    clippy::needless_borrow,
    clippy::needless_continue,
    clippy::path_buf_push_overwrite
)]
#![allow(clippy::too_many_lines)]

pub struct Model {
    age: u8,
    name: String,
}

pub mod huml {
    // the huml object that holds the rules pre validation
    #[derive(Default, Debug)]
    pub struct HumlFrameWork<'a> {
        rules: Vec<ValidationRule<'a>>,
    }

    impl<'a> HumlFrameWork<'a> {
        pub fn new() -> Self {
            Self { rules: vec![] }
        }
    }

    impl<'a> HumlFrameWork<'a> {
        // validate the rules
        #[must_use]
        pub fn validate(&self, data: &crate::Model) -> ValidationSummary {
            let mut val_errors: Vec<ValidationError> = Vec::new();
            let mut fields: Vec<String> = Vec::new();

            for rule in self
                .rules
                .iter()
                .filter(|rule| rule.toggle == RuleToggle::Enabled)
            {
                // run the function on the data model and push validation
                // failures onto the ValidationSummary
                let validation_failed: bool = (rule.function)(data);
                if validation_failed {
                    let val_error = ValidationError {
                        error: rule.error.clone(),
                        fields: rule.fields.clone(),
                    };
                    fields.extend(rule.fields.clone());
                    val_errors.push(val_error);
                }
            }

            let mut summary = ValidationSummary {
                has_errors: !val_errors.is_empty(),
                errors: val_errors,
                fields,
            };
            summary.fields.sort();
            summary.fields.dedup();
            summary
        }

        // adds a new rule to the huml struct
        pub fn append_rule<T: Into<String>>(
            &mut self,
            name: T,
            error: T,
            toggle: RuleToggle,
            fields: Vec<T>,
            function: &'a dyn Fn(&crate::Model) -> bool,
        ) {
            let rule = ValidationRule {
                name: name.into(),
                error: error.into(),
                toggle,
                fields: fields.into_iter().map(std::convert::Into::into).collect(),
                function,
            };
            self.rules.push(rule);
        }
    }
    // expresses if a rule is enabled or disabled
    #[derive(PartialEq, Clone, Debug)]
    pub enum RuleToggle {
        Enabled,
        Disabled,
    }

    // represents a validation rule that which contains some data and a function
    struct ValidationRule<'a> {
        name: String,
        error: String,
        toggle: RuleToggle,
        fields: Vec<String>,
        function: &'a dyn Fn(&crate::Model) -> bool,
    }

    // we want to be able to debug print this but closure do not impl Debug so we have to work around
    impl<'a> std::fmt::Debug for ValidationRule<'a> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "ValidationRule <[ name: {:?}, fields: {:?}, errormsg: {:?}, disabled: {:?}, function: {}, data: {} ]>", self.name, self.fields, self.error, self.toggle, "(omitted):&'a dyn Fn(&crate::MyData) -> bool", "(omitted)&'a crate::MyData")
        }
    }

    // this is essentially a list of validation failures
    #[derive(Debug)]
    pub struct ValidationSummary {
        pub has_errors: bool,
        pub errors: Vec<ValidationError>,
        pub fields: Vec<String>,
    }

    #[derive(Debug, Eq, PartialEq)]
    pub struct ValidationError {
        pub error: String,
        pub fields: Vec<String>,
    }

    // an (in?)complete list of operators can be found here:
    // https://github.com/openvalidation/openvalidation/blob/09ae4e62c9e7d9efae89a307a7dd68f2db252649/openvalidation-common/src/main/java/io/openvalidation/common/ast/ASTComparisonOperator.java#L19
    // OR
    // git grep "public enum AstComparisonOperator"

    // following functions need to be named like this and are run to validate the data

    #[allow(non_snake_case)]
    #[inline]
    pub fn EQUALS<T: PartialEq>(left_operand: &T, right_operand: &T) -> bool {
        left_operand == right_operand
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn NOT_EQUALS<T: PartialEq>(left_operand: &T, right_operand: &T) -> bool {
        !EQUALS(left_operand, right_operand)
    }

    // require partial ord so these work on floats too
    #[allow(non_snake_case)]
    #[inline]
    pub fn LESS_THAN<T: PartialOrd>(left_operand: &T, right_operand: &T) -> bool {
        left_operand < right_operand
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn GREATER_THAN<T: PartialOrd>(left_operand: &T, right_operand: &T) -> bool {
        left_operand > right_operand
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn LESS_OR_EQUALS<T: PartialOrd>(left_operand: &T, right_operand: &T) -> bool {
        left_operand <= right_operand
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn GREATER_OR_EQUALS<T: PartialOrd>(left_operand: &T, right_operand: &T) -> bool {
        left_operand >= right_operand
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn ONE_OF<T>(iterable: T, item: &T::Item) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
    {
        // if there is at least one of
        iterable.into_iter().any(|elm| elm == *item)
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn NONE_OF<T>(iterable: T, item: &T::Item) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
    {
        // if there is none
        !iterable.into_iter().any(|elm| elm == *item)
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn EXACTLY_ONE_OF<T>(iterable: T, item: &T::Item) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
    {
        // if there is exactly one 
        iterable.into_iter().filter(|elm| elm == item).count() == 1
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn AT_LEAST_ONE_OF<T>(iterable: T, item: &T::Item) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
    {
        // if there is at least one of
        iterable.into_iter().filter(|elm| elm == item).count() >= 1
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn EXISTS<T>(item: &Option<T>) -> bool {
        item.is_some()
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn NOT_EXISTS<T>(item: &Option<T>) -> bool {
        item.is_none()
    }

    #[allow(non_snake_case)]
    pub fn SUM_OF<T>(iterable: T) -> T::Item
    where
        T: IntoIterator,
        T::Item: std::iter::Sum,
    {
        iterable.into_iter().sum()
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn EMPTY<T>(vec: &[Vec<T>]) -> bool {
        vec.is_empty()
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn NOT_EMPTY<T>(vec: &[Vec<T>]) -> bool {
        !EMPTY(vec)
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn WHERE<T, F>(iterable: T, function: F) -> bool
    where
        T: IntoIterator,
        T::Item: PartialEq,
        F: Fn(&T::Item) -> bool,
    {
        // if there is at least one of
        iterable.into_iter().filter(|elm| function(elm)).count() >= 1
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn FIRST<T>(iterable: &'_ T, number: usize) -> Vec<T::Item>
    where
        T: IntoIterator + Clone,
    {
        iterable
            .clone()
            .into_iter()
            .take(number)
            .collect::<Vec<_>>()
    }

    #[allow(non_snake_case)]
    #[inline]
    pub fn LAST<T>(iterable: &'_ T, number: usize) -> Vec<T::Item>
    where
        T: DoubleEndedIterator + ExactSizeIterator + Clone,
    {
        //@TODO can we avoid the double reverse somehow?
        iterable
            .clone()
            .rev() // reverse the list
            .take(number) // and only keep the the first N elemets
            .rev() // reverse back to original order
            .collect::<Vec<T::Item>>() // and return as Vec
    }
}

// some tests I used to verify things work as expected
// these should actually not end up in the generated code ...

// note: this should be generated by openVALIDATION actually
pub fn HUMLValidator() {
    let mut huml = huml::HumlFrameWork::new();

    huml.append_rule(
        "rule 1",
        "name has to be Peter and age must be greater than 34",
        huml::RuleToggle::Enabled,
        vec!["name", "age"],
        &|model: &Model| huml::EQUALS(&model.age, &4) && huml::NOT_EQUALS(&"a", &"n")
    );
}


fn main() {
    HUMLValidator();
}
